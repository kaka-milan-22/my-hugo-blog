<!DOCTYPE html>
<html lang="zh"><head><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">HTTP协议的25年进化史：从简单到极致的性能之旅 | 我的技术博客</title>
<meta property="og:title" content="HTTP协议的25年进化史：从简单到极致的性能之旅 | 我的技术博客" />
<meta name="twitter:title" content="HTTP协议的25年进化史：从简单到极致的性能之旅 | 我的技术博客" />
<meta itemprop="name" content="HTTP协议的25年进化史：从简单到极致的性能之旅 | 我的技术博客" />
<meta name="application-name" content="HTTP协议的25年进化史：从简单到极致的性能之旅 | 我的技术博客" />
<meta property="og:site_name" content="" />

<meta name="description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事">
<meta itemprop="description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事" />
<meta property="og:description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事" />
<meta name="twitter:description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事" />

<meta property="og:locale" content="zh" />
<meta name="language" content="zh" />

  <link rel="alternate" hreflang="zh" href="https://blog.kakacn.com/posts/2026-02-13-disk-grow/" title="中文" />





    
    
    

    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content=2026-02-13T10:00:00&#43;0800 />
    <meta property="article:published_time" content=2026-02-13T10:00:00&#43;0800 />
    <meta property="og:url" content="https://blog.kakacn.com/posts/2026-02-13-disk-grow/" />

    
    <meta property="og:article:author" content="Kaka" />
    <meta property="article:author" content="Kaka" />
    <meta name="author" content="Kaka" />
    
    

    

    <script defer type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "HTTP协议的25年进化史：从简单到极致的性能之旅",
        "author": {
        "@type": "Person",
        "name": ""
        },
        "datePublished": "2026-02-13",
        "description": "从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事",
        "wordCount":  5329 ,
        "mainEntityOfPage": "True",
        "dateModified": "2026-02-13",
        "image": {
        "@type": "imageObject",
        "url": ""
        },
        "publisher": {
        "@type": "Organization",
        "name": "我的技术博客"
        }
    }
    </script>


<meta name="generator" content="Hugo 0.156.0">

    
    <meta property="og:url" content="https://blog.kakacn.com/posts/2026-02-13-disk-grow/">
  <meta property="og:site_name" content="我的技术博客">
  <meta property="og:title" content="HTTP协议的25年进化史：从简单到极致的性能之旅">
  <meta property="og:description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-13T10:00:00+08:00">
    <meta property="article:modified_time" content="2026-02-13T10:00:00+08:00">
    <meta property="article:tag" content="HTTP">
    <meta property="article:tag" content="网络协议">
    <meta property="article:tag" content="性能优化">
    <meta property="article:tag" content="Web技术">
    <meta property="article:tag" content="TCP">
    <meta property="article:tag" content="UDP">


    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="HTTP协议的25年进化史：从简单到极致的性能之旅">
  <meta name="twitter:description" content="从HTTP/1.1到HTTP/3，互联网协议如何一步步打破性能瓶颈，解决实际问题的故事">


    

    <link rel="canonical" href="https://blog.kakacn.com/posts/2026-02-13-disk-grow/">
    <link href="/style.min.e390ba7da26222f4dc42a349955d76dbbe44e5ce2535a43de5a70633a0a9ec3c.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="https://blog.kakacn.com/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">
    <meta name="color-scheme" content="light dark">

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    
    
    
</head>
<body data-theme = "" class="notransition">

<script src="/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js" integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="https://blog.kakacn.com/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title></title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        首页
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/posts/">
                        文章
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/tags/">
                        标签
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/about/">
                        关于
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">HTTP协议的25年进化史：从简单到极致的性能之旅</h1>
                
                
                
                <div class="post-meta">
                    <time datetime="2026-02-13T10:00:00&#43;08:00" itemprop="datePublished"> 2026年2月13日 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b></b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#写在前面">写在前面</a></li>
    <li><a href="#第一幕1996-1999互联网的童年">第一幕：1996-1999，互联网的童年</a>
      <ul>
        <li><a href="#那个握手就要等半天的年代">那个握手就要等半天的年代</a></li>
        <li><a href="#http11的第一次革命keep-alive">HTTP/1.1的第一次革命：Keep-Alive</a></li>
      </ul>
    </li>
    <li><a href="#第二幕http11的阿喀琉斯之踵">第二幕：HTTP/1.1的阿喀琉斯之踵</a>
      <ul>
        <li><a href="#队头阻塞大文件的暴政">队头阻塞：大文件的暴政</a></li>
        <li><a href="#前端工程师的缝缝补补">前端工程师的&quot;缝缝补补&quot;</a></li>
      </ul>
    </li>
    <li><a href="#第三幕2015http2的破局之道">第三幕：2015，HTTP/2的破局之道</a>
      <ul>
        <li><a href="#二进制分帧看不见的革命">二进制分帧：看不见的革命</a></li>
        <li><a href="#多路复用终于可以并行了">多路复用：终于可以并行了</a></li>
        <li><a href="#hpack别再重复发送那些header了">HPACK：别再重复发送那些Header了</a></li>
        <li><a href="#server-push我知道你要什么">Server Push：我知道你要什么</a></li>
      </ul>
    </li>
    <li><a href="#第四幕http2的隐藏陷阱">第四幕：HTTP/2的隐藏陷阱</a>
      <ul>
        <li><a href="#tcp层的队头阻塞换汤不换药">TCP层的队头阻塞：换汤不换药？</a></li>
      </ul>
    </li>
    <li><a href="#第五幕http3的革命抛弃tcp">第五幕：HTTP/3的革命——抛弃TCP</a>
      <ul>
        <li><a href="#quic用udp重新发明轮子">QUIC：用UDP重新发明轮子</a></li>
        <li><a href="#0-rtt快到不可思议的握手">0-RTT：快到不可思议的握手</a></li>
        <li><a href="#真正的流独立彻底解决队头阻塞">真正的流独立：彻底解决队头阻塞</a></li>
        <li><a href="#连接迁移从wifi切到4g连接不断">连接迁移：从WiFi切到4G，连接不断</a></li>
      </ul>
    </li>
    <li><a href="#第六幕现状与抉择">第六幕：现状与抉择</a>
      <ul>
        <li><a href="#现在三个世界并存">现在，三个世界并存</a></li>
        <li><a href="#你应该用哪个">你应该用哪个？</a></li>
        <li><a href="#我的实际经验">我的实际经验</a></li>
      </ul>
    </li>
    <li><a href="#尾声技术的意义">尾声：技术的意义</a></li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <p><img src="/images/http.jpg" alt="http"></p>
<h2 id="写在前面">写在前面</h2>
<p>你有没有想过，当你在手机上刷短视频、在地铁里看直播的时候，背后的网络协议经历了怎样的进化？今天我想和你聊聊HTTP协议这25年的故事——一个关于如何不断打破性能瓶颈、解决真实世界问题的技术演进之旅。</p>
<p>作为一个做了15年运维的人，我见证了从HTTP/1.1到HTTP/3的整个演变过程。这不是一场技术的炫技秀，而是工程师们面对真实痛点，一次次妥协、权衡、突破的过程。</p>
<h2 id="第一幕1996-1999互联网的童年">第一幕：1996-1999，互联网的童年</h2>
<h3 id="那个握手就要等半天的年代">那个握手就要等半天的年代</h3>
<p>想象一下1999年的互联网。你打开一个网页，浏览器需要加载HTML、几张图片、一个CSS文件。在HTTP/1.0的世界里，每个文件都需要：</p>
<ol>
<li>建立TCP连接（三次握手）</li>
<li>请求文件</li>
<li>接收文件</li>
<li>关闭连接</li>
</ol>
<p>然后，下一个文件重复这个过程。</p>
<p>我第一次看到这个流程图的时候，脑海里浮现的是一个画面：你去便利店买东西，每买一样商品都要重新排队、结账、走出店门，然后再进来买下一样。荒谬吗？但1999年的HTTP就是这么工作的。</p>
<pre tabindex="0"><code>请求图片1: [握手] → [传输] → [关闭] 
请求图片2: [握手] → [传输] → [关闭]
请求CSS:   [握手] → [传输] → [关闭]
</code></pre><p>那个年代，我们管这叫&quot;短连接&quot;。握手的延迟成了最大的敌人。</p>
<h3 id="http11的第一次革命keep-alive">HTTP/1.1的第一次革命：Keep-Alive</h3>
<p>1999年，HTTP/1.1带来了一个看似简单、却影响深远的改变——<strong>Keep-Alive</strong>（持久连接）。</p>
<p>现在，浏览器可以在一个TCP连接上发送多个请求了：</p>
<pre tabindex="0"><code>[握手] → [请求1] → [请求2] → [请求3] → ... → [关闭]
</code></pre><p>就像你终于可以在便利店一次性买完所有东西，而不用反复进出了。</p>
<p>这个改进统治了互联网整整16年，直到2015年。但它并不完美。</p>
<h2 id="第二幕http11的阿喀琉斯之踵">第二幕：HTTP/1.1的阿喀琉斯之踵</h2>
<h3 id="队头阻塞大文件的暴政">队头阻塞：大文件的暴政</h3>
<p>Keep-Alive解决了握手延迟，但带来了新问题——<strong>队头阻塞</strong>（Head-of-Line Blocking）。</p>
<p>想象这样一个场景：你的网页需要加载一个5MB的JavaScript文件，还有3个小小的CSS文件（每个10KB）。在HTTP/1.1的世界里，如果那个大JS文件先开始下载，三个CSS文件只能排队等待。</p>
<pre tabindex="0"><code>[========大JS文件(5MB)正在传输========] 
                                      ← CSS1(10KB) 在等待
                                      ← CSS2(10KB) 在等待  
                                      ← CSS3(10KB) 在等待
</code></pre><p>你的网络带宽明明还有很多空闲，但就是用不上。这就像高速公路上，一辆大货车占据了所有车道，后面的小汽车再急也只能慢慢跟着。</p>
<h3 id="前端工程师的缝缝补补">前端工程师的&quot;缝缝补补&quot;</h3>
<p>面对这个问题，前端工程师们想出了各种&quot;骚操作&quot;：</p>
<p><strong>1. 域名分片（Domain Sharding）</strong></p>
<p>既然一个域名只能并行6个连接，那我就用多个域名！</p>
<pre tabindex="0"><code>static1.example.com
static2.example.com  
static3.example.com
</code></pre><p>看起来很聪明对吧？但这又绕回去了——更多的域名意味着更多的DNS查询，更多的TCP连接。我们在用一个hack解决另一个hack。</p>
<p><strong>2. 资源合并（Concatenation）</strong></p>
<p>把100个小图片合并成一个大的CSS Sprite，把10个JS文件打包成1个。</p>
<p>这招确实减少了请求数，但代价是什么？任何一个小改动都要重新下载整个大文件。缓存效率极低。</p>
<p><strong>3. 内联资源（Inlining）</strong></p>
<p>干脆把CSS、JS直接塞进HTML里。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">style</span>&gt;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 几千行CSS直接写在这 */</span>
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">style</span>&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>首屏是快了，但HTML文件膨胀到几MB，而且完全没法复用。</p>
<p>作为一个运维，每次看到前端同事这么折腾，我都觉得这不是解决方案，这是在和协议的缺陷做斗争。我们需要的不是workaround，而是真正的解决方案。</p>
<h2 id="第三幕2015http2的破局之道">第三幕：2015，HTTP/2的破局之道</h2>
<h3 id="二进制分帧看不见的革命">二进制分帧：看不见的革命</h3>
<p>HTTP/2的第一个改变，普通用户完全感知不到——从文本协议变成了二进制协议。</p>
<p>HTTP/1.1的请求是这样的：</p>
<pre tabindex="0"><code>GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...
</code></pre><p>人类能读，但机器解析起来很慢，而且浪费带宽。</p>
<p>HTTP/2变成了这样：</p>
<pre tabindex="0"><code>+-----------------------------------------------+
|                 Frame Header                  |
+---------------+---------------+---------------+
| Length (24)   | Type (8)      | Flags (8)     |
+---------------+---------------+---------------+
|                 Payload                       |
+-----------------------------------------------+
</code></pre><p>二进制的，紧凑的，机器友好的。这是革命的基础。</p>
<h3 id="多路复用终于可以并行了">多路复用：终于可以并行了</h3>
<p>但真正的魔法在于<strong>多路复用</strong>（Multiplexing）。</p>
<p>现在，一个TCP连接上可以同时传输多个&quot;流&quot;（Stream）。每个流独立编号，数据帧可以交错传输：</p>
<pre tabindex="0"><code>Stream 1 (index.html):  [帧1] ... [帧2] ... [帧3]
Stream 2 (style.css):   ... [帧1] ... [帧2] ...  
Stream 3 (script.js):   ... [帧1] ... [帧2] ... [帧3]

所有帧在同一个TCP连接上交错传输：
[S1-帧1][S2-帧1][S1-帧2][S3-帧1][S2-帧2]...
</code></pre><p>那个5MB的JS文件再也不能霸占整个连接了。小文件可以见缝插针，充分利用带宽。</p>
<p>我记得第一次在生产环境启用HTTP/2的时候，页面加载时间直接降低了30%。那些域名分片、资源合并的hack，终于可以扔掉了。</p>
<h3 id="hpack别再重复发送那些header了">HPACK：别再重复发送那些Header了</h3>
<p>HTTP/2的另一个巧思是<strong>头部压缩</strong>。</p>
<p>你知道吗？每次HTTP请求都会带上一堆重复的Header：</p>
<pre tabindex="0"><code>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...
Cookie: session=abc123; user_id=456; analytics=xyz...
Accept: text/html,application/xhtml+xml...
</code></pre><p>这些东西在一个会话里基本不变，但每次都要传一遍。</p>
<p>HTTP/2用HPACK算法，维护一个&quot;字典表&quot;。第一次发送完整的Header，之后只发送变化的部分：</p>
<pre tabindex="0"><code>第一次：User-Agent: Mozilla/5.0... (完整发送)
第二次：:path: /new-page (只发送URL变化)
第三次：:path: /another-page
</code></pre><p>在我们的实际业务中，这个优化节省了大约20-40%的Header传输量。不起眼，但积少成多。</p>
<h3 id="server-push我知道你要什么">Server Push：我知道你要什么</h3>
<p>HTTP/2还带来了一个激进的特性——<strong>服务器推送</strong>。</p>
<p>传统模式：</p>
<pre tabindex="0"><code>客户端: 给我index.html
服务器: 好的，给你
客户端: (解析HTML) 哦，还需要style.css和script.js
客户端: 给我style.css
服务器: 好的
客户端: 给我script.js  
服务器: 好的
</code></pre><p>Server Push模式：</p>
<pre tabindex="0"><code>客户端: 给我index.html
服务器: 好的，给你index.html，顺便style.css和script.js我也一起发给你了
客户端: (惊喜) 哦，我正要问你要呢
</code></pre><p>理论很美好，但实际生产中，Server Push的效果并不如预期。因为浏览器缓存的复杂性，很多时候推送的资源其实客户端已经有了，反而浪费带宽。所以这个特性在HTTP/3里被移除了。</p>
<h2 id="第四幕http2的隐藏陷阱">第四幕：HTTP/2的隐藏陷阱</h2>
<h3 id="tcp层的队头阻塞换汤不换药">TCP层的队头阻塞：换汤不换药？</h3>
<p>HTTP/2解决了应用层的队头阻塞，但我们很快发现了一个尴尬的事实——<strong>TCP层的队头阻塞依然存在</strong>。</p>
<p>想象一下，你有三个流在一个TCP连接上传输：</p>
<pre tabindex="0"><code>Stream 1: [帧1][帧2][X帧3丢失][帧4]...
Stream 2: [帧1][帧2][帧3]... ← 等待中
Stream 3: [帧1][帧2][帧3]... ← 等待中
</code></pre><p>TCP是一个<strong>可靠的、有序的</strong>传输协议。如果Stream 1的帧3丢失了，TCP会等待重传，<strong>所有流都会被阻塞</strong>，即使Stream 2和Stream 3的数据已经全部到达。</p>
<p>这就像你在超市排队结账，前面的人掏钱包掏了半天，你再急也得等着，哪怕你的东西早就扫完了。</p>
<p>在弱网环境（比如地铁里的移动网络），丢包率可能达到1-5%。这时候HTTP/2的性能反而可能比HTTP/1.1还差。</p>
<p>我在2018年做过一次测试，在模拟的弱网环境下（3%丢包率），HTTP/2的延迟竟然比HTTP/1.1高了15%。这是一个大问题。</p>
<h2 id="第五幕http3的革命抛弃tcp">第五幕：HTTP/3的革命——抛弃TCP</h2>
<h3 id="quic用udp重新发明轮子">QUIC：用UDP重新发明轮子</h3>
<p>Google的工程师们做了一个大胆的决定：<strong>既然TCP有问题，那就不用TCP了</strong>。</p>
<p>他们基于UDP协议，从头实现了一个新的传输层协议——<strong>QUIC</strong>（Quick UDP Internet Connections）。</p>
<pre tabindex="0"><code>HTTP/2 的协议栈：
┌─────────────┐
│   HTTP/2    │
├─────────────┤
│  TLS 1.3    │
├─────────────┤
│     TCP     │ ← 内核实现，改不了
├─────────────┤
│     IP      │
└─────────────┘

HTTP/3 的协议栈：
┌─────────────────────────┐
│        HTTP/3           │
├─────────────────────────┤
│         QUIC            │ ← 用户态实现，可以快速迭代
│ (可靠性+加密+拥塞控制)  │
├─────────────────────────┤
│          UDP            │
├─────────────────────────┤
│          IP             │
└─────────────────────────┘
</code></pre><p>为什么是UDP？因为UDP简单、无状态，内核实现稳定。在UDP之上，QUIC重新实现了可靠性、拥塞控制、加密——但这次是在用户态，可以快速迭代改进。</p>
<h3 id="0-rtt快到不可思议的握手">0-RTT：快到不可思议的握手</h3>
<p>TCP+TLS建立连接需要2-3个往返时间（RTT）：</p>
<pre tabindex="0"><code>客户端                    服务器
  |                          |
  | -------- SYN ---------&gt;  | \
  | &lt;----- SYN-ACK -------   |  } TCP握手 (1 RTT)
  | -------- ACK ---------&gt;  | /
  |                          |
  | ---- ClientHello ----&gt;   | \
  | &lt;---- ServerHello ----   |  |
  | &lt;---- Certificate ----   |  } TLS握手 (1-2 RTT)  
  | -- ClientKeyExchange -&gt;  |  |
  | ---- Finished --------&gt;  | /
  |                          |
  | -------- Data ---------&gt;  |
</code></pre><p>总共2-3个RTT才能开始传输数据。如果你在新加坡访问美国的服务器，单程延迟200ms，光握手就要花400-600ms。</p>
<p>QUIC的首次连接只需要1-RTT：</p>
<pre tabindex="0"><code>客户端                    服务器
  |                          |
  | -- Initial (含密钥) --&gt;  | \
  | &lt;--- Handshake -------   | } 1-RTT
  | -------- Data ---------&gt;  |
</code></pre><p>更激进的是，如果你之前连接过这个服务器，QUIC可以做到<strong>0-RTT</strong>：</p>
<pre tabindex="0"><code>客户端                    服务器
  |                          |
  | - 0-RTT Data (含会话票据) -&gt;  | 0-RTT！数据直接发送
</code></pre><p>第一个数据包就带着实际请求，不需要等待任何握手。</p>
<p>我第一次看到0-RTT的效果时，真的惊呆了。在我们的CDN上，平均首字节时间（TTFB）降低了50ms以上。对于移动端用户，这是巨大的提升。</p>
<h3 id="真正的流独立彻底解决队头阻塞">真正的流独立：彻底解决队头阻塞</h3>
<p>QUIC的流是真正独立的：</p>
<pre tabindex="0"><code>Stream 1: [帧1][帧2][X丢失][帧4]  ← 只有Stream 1阻塞
Stream 2: [帧1][帧2][帧3][帧4]    ← 正常传输
Stream 3: [帧1][帧2][帧3][帧4]    ← 正常传输
</code></pre><p>一个流丢包，只影响这个流自己。其他流该怎么传就怎么传。</p>
<p>在移动网络环境下，这个特性太关键了。用户在地铁里刷视频，信号时好时坏，QUIC能保证即使部分数据丢失，其他内容依然流畅加载。</p>
<h3 id="连接迁移从wifi切到4g连接不断">连接迁移：从WiFi切到4G，连接不断</h3>
<p>这可能是QUIC最贴近移动用户体验的特性了。</p>
<p>TCP连接是由四元组标识的：(源IP, 源端口, 目标IP, 目标端口)。当你从WiFi切换到4G，IP地址变了，TCP连接就断了，需要重新建立。</p>
<pre tabindex="0"><code>家里WiFi(192.168.1.100) → 地铁4G(10.x.x.x)
                          ↓
                    TCP连接断开
                          ↓
                     重新握手(1-2 RTT)
</code></pre><p>QUIC用**连接ID（CID）**标识连接，而不是四元组。IP变了没关系，连接ID不变，连接就还在：</p>
<pre tabindex="0"><code>WiFi(192.168.1.100) → 4G(10.x.x.x)
         ↓
   连接ID: abc123 (不变)
         ↓
    连接无缝切换
</code></pre><p>作为一个经常通勤的人，我太懂这个痛点了。以前看YouTube，出了地铁站，从4G切到WiFi，视频会卡顿重新缓冲。现在有了QUIC，这个过程完全无感。</p>
<h2 id="第六幕现状与抉择">第六幕：现状与抉择</h2>
<h3 id="现在三个世界并存">现在，三个世界并存</h3>
<p>截至2024年，互联网上大约：</p>
<ul>
<li><strong>30%的流量还在用HTTP/1.1</strong> - 主要是内部API、遗留系统</li>
<li><strong>60%在用HTTP/2</strong> - 这是当前的主流标准</li>
<li><strong>25%已经切换到HTTP/3</strong> - 而且这个数字在快速增长</li>
</ul>
<h3 id="你应该用哪个">你应该用哪个？</h3>
<p>这是我最常被问到的问题。我的答案是：<strong>看场景</strong>。</p>
<p><strong>继续用HTTP/1.1，如果：</strong></p>
<ul>
<li>你的服务是内网API，延迟本来就很低</li>
<li>你需要用tcpdump这类工具调试，可读性很重要</li>
<li>你的客户端不支持新协议（比如某些老旧的IoT设备）</li>
</ul>
<p><strong>升级到HTTP/2，如果：</strong></p>
<ul>
<li>你是面向公网的Web服务</li>
<li>你的用户主要用现代浏览器</li>
<li>你希望优化带宽利用率</li>
<li><strong>这是当下最稳妥的选择</strong></li>
</ul>
<p><strong>激进地上HTTP/3，如果：</strong></p>
<ul>
<li>你的用户是移动端为主</li>
<li>你做视频流、直播这类实时性要求高的业务</li>
<li>你的用户在弱网环境（比如东南亚、印度）</li>
<li>你追求极致的首屏速度</li>
</ul>
<h3 id="我的实际经验">我的实际经验</h3>
<p>在我们公司，我们是这样做的：</p>
<ol>
<li><strong>API服务器（内网）</strong>：保持HTTP/1.1，简单可靠，便于调试</li>
<li><strong>Web前端（CDN）</strong>：全面启用HTTP/2，必要时自动降级HTTP/1.1</li>
<li><strong>移动端App</strong>：逐步迁移到HTTP/3，用Cloudflare的边缘网络支持</li>
</ol>
<p>迁移过程中，最重要的是<strong>做好监控</strong>。我们会追踪：</p>
<ul>
<li>各协议的使用率</li>
<li>平均延迟（P50、P95、P99）</li>
<li>错误率</li>
<li>连接复用率（HTTP/2/3特有）</li>
<li>0-RTT成功率（HTTP/3特有）</li>
</ul>
<h2 id="尾声技术的意义">尾声：技术的意义</h2>
<p>写到这里，我突然想起2019年的一件事。</p>
<p>我们的一个客户做在线教育，用户主要在印度。他们反馈视频加载很慢，转化率很低。我们帮他们分析发现，印度的移动网络丢包率平均在3-5%，高峰期能到10%。</p>
<p>我们把他们的CDN切换到支持HTTP/3的节点，同时优化了QUIC的拥塞控制参数。一周后，他们的数据变成了这样：</p>
<ul>
<li>视频首帧时间从4.5秒降到1.8秒</li>
<li>卡顿率从18%降到5%</li>
<li>最终转化率提升了23%</li>
</ul>
<p>这就是技术的意义。不是为了炫技，不是为了写在PPT上，而是真正解决实际问题，给真实的人带来更好的体验。</p>
<p>HTTP从1.1到2到3的进化，本质上是工程师们在不断回答同一个问题：<strong>如何让数据传输更快、更稳定、更高效</strong>。</p>
<p>25年了，这个问题还在继续，答案也在继续演进。</p>
<p>也许再过5年，我们会在这里讨论HTTP/4。但无论如何，这个不断打破瓶颈、持续优化的过程，正是我热爱这个行业的原因。</p>
<hr>
<p><em>如果你对HTTP协议的技术细节感兴趣，欢迎在评论区讨论。如果你在生产环境中有HTTP/2或HTTP/3的实践经验，也欢迎分享。</em></p>
<p><em>下一篇，我们聊聊QUIC协议的拥塞控制算法，以及在高丢包率环境下的调优实践。</em></p>
            </div>
        </article></main>
</div>
<footer class="footer">
    <span class="footer_item"> </span>
    &nbsp;

    <div class="footer_social-icons">
<a href="https://github.com/kaka-milan-22" target="_blank" rel="noopener noreferrer me"
    title="Github">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
</a>
<a href="https://x.com/kaka99859362" target="_blank" rel="noopener noreferrer me"
    title="Twitter">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z">
    </path>
</svg>
</a>
<a href="mailto:kaka@kakacn.com" target="_blank" rel="noopener noreferrer me"
    title="Email">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
    <polyline points="22,6 12,13 2,6"></polyline>
</svg>
</a>
</div>
    <small class="footer_copyright">
        © 2026 Kaka.
        
    </small>
</footer>







    
    <script src="https://blog.kakacn.com/js/main.min.4ee188e1744c19816e95a540b2650ed9f033ea0371e74eac8e717355cfca8741.js" integrity="sha256-TuGI4XRMGYFulaVAsmUO2fAz6gNx506sjnFzVc/Kh0E="></script>

    

</body>
</html>
